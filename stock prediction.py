# -*- coding: utf-8 -*-
"""FINAL_stockprediction_final_sem4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ivV1uTM_zQLUgj-AZmF__5EVk_gQBKYa
"""

# ==============================
# ðŸ“† LSTM Price + Direction Prediction for AAPL
# ==============================
# 1. Libraries
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout, Bidirectional
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau
!pip install keras_tuner
import keras_tuner as kt
!pip install ta
import ta

# 2. Load and Feature Engineering
stock_data = yf.download('AAPL', start='2015-01-01', end='2023-12-31')
stock_data['RSI'] = ta.momentum.RSIIndicator(close=stock_data['Close'].squeeze()).rsi()
stock_data['MACD'] = ta.trend.MACD(close=stock_data['Close'].squeeze()).macd()
stock_data['SMA_20'] = ta.trend.SMAIndicator(close=stock_data['Close'].squeeze(), window=20).sma_indicator()
stock_data['Close_lag_1'] = stock_data['Close'].shift(1)
stock_data['Return_1'] = stock_data['Close'].pct_change()
stock_data['Direction'] = np.where(stock_data['Close'].shift(-1) > stock_data['Close'], 1, 0)
stock_data.dropna(inplace=True)

# 3. Preprocessing
features = ['Close', 'RSI', 'MACD', 'SMA_20', 'Return_1', 'Close_lag_1']
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(stock_data[features])
close_index = features.index('Close')
y_scaled = scaled_data[:, close_index]

# 4. Sequence Preparation
def create_dataset(data, labels, time_step=100):
    X, y = [], []
    for i in range(len(data) - time_step - 1):
        X.append(data[i:i + time_step])
        y.append(labels[i + time_step])
    return np.array(X), np.array(y)

time_step = 100
X_price, y_price = create_dataset(scaled_data, y_scaled, time_step)
X_dir, y_dir = create_dataset(scaled_data, stock_data['Direction'].values, time_step)

# 5. Train-Test Split
split = int(len(X_price) * 0.65)
X_train_price, X_test_price = X_price[:split], X_price[split:]
y_train_price, y_test_price = y_price[:split], y_price[split:]
X_train_dir, X_test_dir = X_dir[:split], X_dir[split:]
y_train_dir, y_test_dir = y_dir[:split], y_dir[split:]

# 6. Hyperparameter Tuning for Price Prediction

def build_price_model(hp):
    model = Sequential()
    model.add(LSTM(units=hp.Int('units1', 32, 128, step=32), return_sequences=True, input_shape=(time_step, X_price.shape[2])))
    model.add(Dropout(hp.Float('dropout1', 0.1, 0.5, step=0.1)))
    model.add(LSTM(units=hp.Int('units2', 32, 128, step=32)))
    model.add(Dropout(hp.Float('dropout2', 0.1, 0.5, step=0.1)))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mean_squared_error')
    return model

tuner_price = kt.RandomSearch(build_price_model, objective='val_loss', max_trials=5, overwrite=True, directory='tuner', project_name='price')
tuner_price.search(X_train_price, y_train_price, epochs=10, validation_data=(X_test_price, y_test_price), callbacks=[EarlyStopping(patience=5)])
model_price = tuner_price.get_best_models(num_models=1)[0]

# 7. Inverse Scaling Helper
def inverse_close(pred, feature_index, reference_shape):
    pad = np.zeros((len(pred), reference_shape))
    pad[:, feature_index] = pred.flatten()
    return scaler.inverse_transform(pad)[:, feature_index]

train_pred_price = model_price.predict(X_train_price)
test_pred_price = model_price.predict(X_test_price)
train_inv = inverse_close(train_pred_price, close_index, len(features))
test_inv = inverse_close(test_pred_price, close_index, len(features))
y_train_inv = inverse_close(y_train_price.reshape(-1, 1), close_index, len(features))
y_test_inv = inverse_close(y_test_price.reshape(-1, 1), close_index, len(features))

# 8. Price Metrics
print("=== Price Prediction Metrics ===")
print(f"MSE:  {mean_squared_error(y_test_inv, test_inv):.4f}")
print(f"MAE:  {mean_absolute_error(y_test_inv, test_inv):.4f}")
print(f"RMSE: {np.sqrt(mean_squared_error(y_test_inv, test_inv)):.4f}")
print(f"R2:   {r2_score(y_test_inv, test_inv):.4f}")

# 9. Hyperparameter Tuning for Direction Classifier

def build_dir_model(hp):
    model = Sequential()
    model.add(Bidirectional(LSTM(units=hp.Int('units1', 32, 128, step=32), return_sequences=True), input_shape=(time_step, X_dir.shape[2])))
    model.add(Dropout(hp.Float('dropout1', 0.1, 0.5, step=0.1)))
    model.add(Bidirectional(LSTM(units=hp.Int('units2', 32, 128, step=32))))
    model.add(Dropout(hp.Float('dropout2', 0.1, 0.5, step=0.1)))
    model.add(Dense(1, activation='sigmoid'))
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return model

tuner_dir = kt.RandomSearch(build_dir_model, objective='val_accuracy', max_trials=5, overwrite=True, directory='tuner', project_name='direction')
tuner_dir.search(X_train_dir, y_train_dir, epochs=10, validation_data=(X_test_dir, y_test_dir), callbacks=[EarlyStopping(patience=5)])
model_dir = tuner_dir.get_best_models(num_models=1)[0]

# 10. Classification Metrics
pred_dir_probs = model_dir.predict(X_test_dir)
pred_dir_binary = (pred_dir_probs > 0.5).astype(int)

print("\n=== Direction Classification Metrics ===")
print(f"Accuracy:  {accuracy_score(y_test_dir, pred_dir_binary):.4f}")
print(f"Precision: {precision_score(y_test_dir, pred_dir_binary):.4f}")
print(f"Recall:    {recall_score(y_test_dir, pred_dir_binary):.4f}")
print(f"F1 Score:  {f1_score(y_test_dir, pred_dir_binary):.4f}")

# 11. Trading Signal
last_rsi = stock_data['RSI'].iloc[-1]
last_pred_price = test_inv[-1]
last_real_price = y_test_inv[-1]
predicted_trend = "Up" if last_pred_price > last_real_price else "Down"

def trading_signal(direction, rsi):
    if direction == "Up" and rsi < 30:
        return "Buy"
    elif direction == "Down" and rsi > 70:
        return "Sell"
    return "Hold"

signal = trading_signal(predicted_trend, last_rsi)

print("\n=== Final Trading Signal ===")
print(f"Last Real Price:     {last_real_price:.2f}")
print(f"Predicted Price:     {last_pred_price:.2f}")
print(f"Direction Predicted: {predicted_trend}")
print(f"RSI:                 {last_rsi:.2f}")
print(f"Suggested Action:    {signal}")

plt.figure(figsize=(12, 6))
plt.plot(y_test_inv, label='Actual')
plt.plot(test_inv, label='Predicted')
plt.legend()
plt.title("Price Prediction")
plt.show()

#ACTUAL VS PREDICTED CLOSING PRICES
plt.figure(figsize=(12, 6))
plt.plot(y_test_inv, label='Actual Close Price')
plt.plot(test_inv, label='Predicted Close Price')
plt.title("Actual vs Predicted Closing Prices (Test Set)")
plt.xlabel("Time")
plt.ylabel("Price (USD)")
plt.legend()
plt.grid(True)
plt.show()

#PREDICTION ERROR DISTRIBUTION (PRICE MODEL DISTRIBUTION)
errors = y_test_inv - test_inv
plt.figure(figsize=(10, 5))
plt.hist(errors, bins=50, color='orange', edgecolor='black')
plt.title("Prediction Error Distribution")
plt.xlabel("Prediction Error (USD)")
plt.ylabel("Frequency")
plt.grid(True)
plt.show()

#DIRECT CLASSIFICATION (CONFUSION MATRIX)
from sklearn.metrics import confusion_matrix
import seaborn as sns

cm = confusion_matrix(y_test_dir, pred_dir_binary)

plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', cbar=False)
plt.title("Confusion Matrix for Direction Prediction")
plt.xlabel("Predicted Label")
plt.ylabel("True Label")
plt.show()

#FEATURE IMPORTANCE CORRELATION MAP
plt.figure(figsize=(8, 6))
sns.heatmap(stock_data[features].corr(), annot=True, cmap='coolwarm')
plt.title("Feature Correlation Heatmap")
plt.show()

#TRAINING VS VALIDATION LOSS CURVES
history = model_dir.fit(X_train_dir, y_train_dir,
                        validation_data=(X_test_dir, y_test_dir),
                        epochs=10, batch_size=64, verbose=1,
                        callbacks=[EarlyStopping(patience=5)])

plt.figure(figsize=(10, 5))
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title("Training vs Validation Loss (Direction Model)")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()
plt.grid(True)
plt.show()

#PRICE PREDICTION METRICS BAR PLOT
# Price Prediction Metrics
mse = mean_squared_error(y_test_inv, test_inv)
mae = mean_absolute_error(y_test_inv, test_inv)
rmse = np.sqrt(mse)
r2 = r2_score(y_test_inv, test_inv)

metrics_price = {'MSE': mse, 'MAE': mae, 'RMSE': rmse, 'R2': r2}

plt.figure(figsize=(8, 5))
plt.bar(metrics_price.keys(), metrics_price.values(), color=['skyblue', 'lightgreen', 'lightcoral', 'mediumpurple'])
plt.title("Price Prediction Metrics")
plt.ylabel("Score")
for i, v in enumerate(metrics_price.values()):
    plt.text(i, v + 0.01, f"{v:.2f}", ha='center', fontweight='bold')
plt.grid(True, axis='y')
plt.show()

#DIRECTION PREDICTION METRICS BAR PLOT
# Direction Prediction Metrics
acc = accuracy_score(y_test_dir, pred_dir_binary)
prec = precision_score(y_test_dir, pred_dir_binary)
rec = recall_score(y_test_dir, pred_dir_binary)
f1 = f1_score(y_test_dir, pred_dir_binary)

metrics_dir = {'Accuracy': acc, 'Precision': prec, 'Recall': rec, 'F1 Score': f1}

plt.figure(figsize=(8, 5))
plt.bar(metrics_dir.keys(), metrics_dir.values(), color=['cornflowerblue', 'lightcoral', 'gold', 'mediumseagreen'])
plt.title("Direction Prediction Metrics")
plt.ylabel("Score")
plt.ylim(0, 1)  # because these are percentages
for i, v in enumerate(metrics_dir.values()):
    plt.text(i, v + 0.02, f"{v:.2f}", ha='center', fontweight='bold')
plt.grid(True, axis='y')
plt.show()